\sectioncentered*{Введение}
\addcontentsline{toc}{chapter}{Введение}
\label{sec:intro}

В последние годы требования к приложениям значительно изменились. С ростом объёмов информации, требуются новые способы их обработки. Пользователям требуется быстрый доступ к новой информации и возможность получения данных в реальном времени. Это стимулирует разработчиков создавать отзывчивые интерфейсы и модели для обработки. Десятки серверов, время отклика в несколько секунд, оффлайновое обслуживание, которое могло длиться часами, гигабайты данных - такими были большие приложения буквально несколько лет назад. Сегодня же приложения работают абсолютно на всём, начиная с простых мобильников и заканчивая кластерами из тысячи процессоров. Пользователи ожидают миллисекундного времени отклика и стопроцентного аптайма, в то время как данные выросли до петабайтов.

Новые требования требуют новых решений. Раньше делался акцент на повышение мощности аппаратной части системы. Масштабирование достигалось засчёт покупки более крутых серверов и использования многопоточности. Для добавления новых серверов приходилось применять комплексные, неэффективные и дорогие проприетарные решения.

Однако прогресс не стоит на месте. Архитектура приложений изменяется в соответствии с новыми требованиями. Новые архитектуру позволяют разработчикам создавать событийно-ориентированные, масштабируемые, отказоустойчивые и отзывчивые приложения - приложения, работающие в реальном времени и обеспечивающие хорошее время реакции, основанные на масштабируемом и отказоустойчивом стеке и которые легко развернуть на многоядерных и облачных архитектурах. Эти особенности критически важны для реактивности.

Стремясь к упрощению разработки сложных систем, было разработано множество парадигм программирования, каждая из созданных парадигм занимает свою нишу. Все парадигмы разделяются на две большие группы:

\begin{itemize}
  \item императивные;
  \item декларативные;
\end{itemize}

Также существует множество парадигм, которые имеют черты как императивных так и декларативных систем. Одна из них - Functional Reactive Programming (FRP). Она объединяет черты функционального и реактивного программирования.

Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Как известно, функциональный подход к программированию имеет свою специфику: в нём мы преобразовываем данные, а не меняем их. Соответственно, не предполагает оно и изменяемость этого состояния. Но это накладывает свои ограничения, например, при создании программ активно взаимодействующих с пользователем. В императивном языке намного проще реализовать такое поведение, ведь мы можем реагировать на какие-либо события «в реальном времени», в то время как в чистых функциональных языках нам придётся откладывать общение с системой до самого конца. Реактивное программирование ориентируется на потоки данных и распространение изменений. Функциональное реактивное программирование объединяет принципы функционального программирования и реактивного программирование:

\begin{itemize}
  \item преобразование данных;
  \item распространение изменений;
\end{itemize}

Приложения, разработанные на основе этой архитектуры, называются реактивными приложениями. Словарь Merriam Webster даёт определение реактивному как «готовому реагировать на внешние события», что означает что компоненты всё время активны и всегда готовы получать сообщения~\cite{merriam_webster}. Это определение раскрывает суть реактивных приложений, фокусируясь на системах, которые:

\begin{itemize}
  \item реагируют на события;
  \item реагируют на повышение нагрузки;
  \item реагируют на сбои;
  \item реагируют на пользователей;
\end{itemize}

Каждая из этих характеристик существенна для реактивного приложения. Все они зависят друг от друга, но не как ярусы стандартной многоуровневой архитектуры. Напротив, они описывают свойства, применимые на всём стеке технологий.
